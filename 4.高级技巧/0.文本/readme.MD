1. 误区

    在设计产品时，由于不少产品经理、工程师并没有「字符不一定等宽」的概念，往往会给出「超过 n 个字符截断显示，英文数字算一个字符，汉字算两个字符」这样的需求。要知道，这里面的问题有很多：
    
    为了显示效果，前端往往会采用优先西文字体族的 font-family 设置，即西文字符用西文字体，汉字用中文字体，这就很容易使得文本的宽度不好根据字符数来控制。首先，非代码的内容本身就不一定适合用等宽西文字体显示。其次即使用了等宽西文字体，汉字也基本不可能正好是其两倍宽。满足这个需求的，只能放弃西文字体，让西文字符也使用中文字体，并且使用中易系列的几个字体了（比如 SimSun，也就是 Windows 下的「宋体」）。（丑不说，还只能满足 Windows 下的需求。）
    
    这种需求甚至在很多时候还会和某些字符编码长度的概念产生混淆，催生「长度限制 n 个字节，其中英文数字算 1 字节、汉字算 2 字节」这样的奇葩说法。
    
    顺便歪个楼，这种「西文等宽、汉字占两倍宽度」的需求正常情况下只会存在于程序员的代码编辑器里。如果你是这种强迫症晚期，又不想用中易宋体，可以考虑试试 Belleve 制作的 Inziu 。

1. 思路和原理

    对于前端来说，数据库存储的限制不应该是我们需要关心的问题。看下前面的「伪需求」，我们实际的需求往往是从视觉角度出发的「超出特定高度截断显示」或「超出特定行数阶段显示」两种。由于实现方式的差异，其实可以分为「单行截断」、「多行截断」、「按高度截断」几种。从成本和效果来看，有「实现难度」、「效果精确度」、「对内容是否有限制」、「是否能响应页面变化」这些需要考虑的细节。本文里不准备列各种实现的代码，仅谈谈一些相关的问题和思路。
    
    我想这个没有什么好多说的，自从 Firefox 7 开始支持这个 CSS 属性以后，这已经成为了 99% 情况下实现单行文本截断的不二之选。实现难度几乎为零、截断效果精准、内容中也可以有图片、链接等其他内容，而且在宽度变化时能够自动响应， 兼容性也非常好 （当然在低版本 IE 下可能会遇到一些需要额外套一层元素的特殊情况）。要支持 Firefox 7 以下的版本怎么办？尽量把需求拍回去吧。实在不行再考虑别的方案。
    
    但是如果附加上其他的需求，纯 CSS 的方案可能也有不能满足的情况。比如有时候我们可能想仅在文字被截断时才在鼠标移入后通过浮层显示全部文本，又有时行末有不能被截掉的但宽度不定的内容。

1. 计算内容行数

    在 WebKit 浏览器下实现限制显示行数可以使用非标准实现 -webkit-line-clamp 这个 CSS 属性，这个也是大家熟知的。在移动端应用的场景可能还多一些，桌面端很难只支持 WebKit 浏览器。当 CSS 无法直接解决这个问题时，用 JavaScript 如何解决这个问题呢？
    
    比较容易想到的是用高度除以行高，在不给定行高的情况下，需要通过 getComputedStyle 来获取实际行高。但当 line-height 取默认值时计算值为 normal ，数值并不一定是确定值。所以通过 line-height 进行计算适用于自行指定行高数值的场景。例如在 Clamp.js 中，对 normal 值就是 假设所有浏览器默认值为 1.2 的来处理。更别说可能有超出行高的图片等内容，使得高度并非行高乘以行数。
    
    除此之外，据我所知可以用来比较 精确 地判断内容行数的方法主要有下面两个。这类方法的特点是行高并不需要是一个固定值，比如中间有内嵌的图标改变了行高。暂且不讨论限定不确定高度的行数本身是否合理（因为我们显示内容时高度的限制往往并非来源于行数，而是来源于高度的限制），来看看具体的做法。
    
    利用 Element.getClientRects()
    
    根据测试，在 IE8+ 及其他现代浏览器下这个方法对于 display: inline 的元素有一个特性：调用结果返回的 DOMRectList 对象的 length 等于元素渲染后的行数。这样，我们可以把需要计算行数的内容放在一个 display: inline 的容器内（比如原来是 <p> 元素内的文本，现在更改为 p > span 这种结构），对该 <span> 元素调用 elem.getClientRects().length 即可获得行数。
    
    可是目前在 WebKit 下，有一个 疑似 的 bug：当这个 display: inline 的容器内有子元素， getClientRects 的结果会包含这些子元素的轮廓，导致计数错误。既然规范并没有详细描述这个方法的计算逻辑，为什么说是一个 疑似 bug 呢？因为当给容器加上一些特定的样式，计算结果又会和我们预期的结果相符了。详情可参考这个 issue 和 demo 。
    
    利用 Selection.modify()

    这是一个非标准的 DOM 接口，但是 WebKit 和 Gecko 都进行了实现（IE/Edge 都不支持）。